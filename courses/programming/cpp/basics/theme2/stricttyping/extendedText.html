<h2>Сильная и слабая типизация</h2>
<p>Понятия "сильный" и "слабый" &mdash; очень неоднозначные. Вот некоторые примеры их использования:</p>
<ul>
    <li>
        <p>Иногда "сильный" означает "статический".<br />Тут все просто, но лучше использовать термин "статический", потому что большинство используют и понимают его.</p>
    </li>
    <li>
        <p>Иногда "сильный" означает "не делает неявное преобразование типов".<br />Например, JavaScript позволяет написать&nbsp;<code>"a" + 1</code>, что можно назвать "слабой типизацией". Но почти все языки предоставляют тот или иной уровень неявного преобразования, которое позволяет автоматически переходить от целых чисел к числам с плавающей запятой вроде&nbsp;<code>1 + 1.1</code>. В реальности, большинство людей используют слово "сильный" для определения границы между приемлемым и неприемлемым преобразованием. Нет какой-то общепринятой границы, они все неточные и зависят от мнения конкретного человека.</p>
    </li>
    <li>
        <p>Иногда "сильный" означает, что невозможно обойти строгие правила типизации в языке.</p>
    </li>
    <li>Иногда "сильный" означает безопасный для памяти (memory-safe).<br />Си &mdash; это пример небезопасного для памяти языка. Если&nbsp;<code>xs</code>&nbsp;&mdash; это массив четырех чисел, то Си с радостью выполнит код&nbsp;<code>xs[5]</code>&nbsp;или&nbsp;<code>xs[1000]</code>, возвращая какое-то значение из памяти, которая находится сразу за&nbsp;<code>xs</code>.</li>
</ul>
<p>Давайте остановимся. Вот как некоторые языки отвечают этим определениям. Как можно заметить, только Haskell последовательно "сильный" по всем параметрам. Большинство языков не такие четкие.</p>
<table class="table table-bordered table-striped">
    <thead class="thead-dark">
        <tr>
            <th scope="col">Язык</th>
            <th scope="col">Статический?</th>
            <th scope="col">Неявные преобразования?</th>
            <th scope="col">Строгие правила?</th>
            <th scope="col">Безопасный для памяти?</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>C</td>
            <td>Сильный</td>
            <td>Когда как</td>
            <td>Слабый</td>
            <td>Слабый</td>
        </tr>
        <tr>
            <td>Java</td>
            <td>Сильный</td>
            <td>Когда как</td>
            <td>Сильный</td>
            <td>Сильный</td>
        </tr>
        <tr>
            <td>Haskell</td>
            <td>Сильный</td>
            <td>Сильный</td>
            <td>Сильный</td>
            <td>Сильный</td>
        </tr>
        <tr>
            <td>Python</td>
            <td>Слабый</td>
            <td>Когда как</td>
            <td>Слабый</td>
            <td>Сильный</td>
        </tr>
        <tr>
            <td>JavaScript</td>
            <td>Слабый</td>
            <td>Слабый</td>
            <td>Слабый</td>
            <td>Сильный</td>
        </tr>
    </tbody>
</table>
<p>("Когда как" в колонке "Неявные преобразования" означает, что разделение между сильным и слабым зависит от того, какие преобразования мы считаем приемлемыми).</p>
<p>Зачастую термины "сильный" и "слабый" относятся к неопределенной комбинации разных определений выше, и других, не показанных здесь определений. Весь этот беспорядок делает слова "сильный" и "слабый" практически бессмысленными. Когда хочется использовать эти термины, то лучше описать, что конкретно имеется ввиду. Например, можно сказать, что "JavaScript возвращает значение, когда складывается строка с числом, но Python возвращает ошибку". В таком случае мы не будем тратить свои силы на попытки прийти к соглашению о множестве значений слова "сильный". Или, еще хуже: придем к неразрешенному непониманию из-за терминологии.</p>
<p>В большинстве случаев термины "сильный" и "слабый" в интернете являются неясными и плохо определенными мнениями конкретных людей. Они используются, чтобы назвать язык "плохим" или "хорошим", и это мнение оборачивается в технический жаргон.</p>
<p>Как&nbsp;<a href="https://cdsmith.wordpress.com/2011/01/09/an-old-article-i-wrote/">написал Крис Смит</a>:</p>
<blockquote>Сильная типизация: Система типов, которую я люблю и с которой мне комфортно.<br /><br />Слабая типизация: Система типов, которая беспокоит меня или с которой мне не комфортно.</blockquote>
<h2>Компиляция статически типизированного кода</h2>
<p>Когда происходит компиляция статически типизированного кода, сначала проверяется синтаксис, как в любом компиляторе. Потом проверяются типы. Это означает, что статический язык сначала может пожаловаться на одну синтаксическую ошибку, а после ее исправления пожаловаться на 100 ошибок типизации. Исправление синтаксической ошибки не создало эти 100 ошибок типизации. Компилятор просто не имел возможности обнаружить ошибки типов, пока не был исправлен синтаксис.</p>
<p>Компиляторы статических языков обычно могут генерировать более быстрый код, чем компиляторы динамических. Например, если компилятор знает, что функция add принимает целые числа, то он может использовать нативную инструкцию ADD центрального процессора. Динамический язык будет проверять тип при выполнении, выбирая один из множества функций add в зависимости от типов (складываем integers или floats или склеиваем строки или, может быть, списки?) Или нужно решить, что возникла ошибка и типы не соответствуют друг другу. Все эти проверки занимают время. В динамических языках используются разные трюки для оптимизации, например JIT-компиляция (just-in-time), где код перекомпилируется при выполнении после получения всей необходимой о типах информации. Однако, никакой динамический язык не может сравниться по скоростью с аккуратно написанным статическим кодом.</p>
